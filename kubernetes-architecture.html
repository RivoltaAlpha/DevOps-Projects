<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kubernetes Architecture Simplified</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
            min-height: 100vh;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        
        h1 {
            color: #2d3748;
            margin-bottom: 20px;
            text-align: center;
            font-size: 2.5em;
        }
        
        .intro {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            font-size: 1.1em;
            line-height: 1.6;
        }
        
        .cluster-diagram {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 30px 0;
        }
        
        .master-section, .node-section {
            border: 3px solid #e2e8f0;
            border-radius: 15px;
            padding: 25px;
            background: #f7fafc;
        }
        
        .master-section {
            border-color: #667eea;
            background: linear-gradient(135deg, #eef2ff 0%, #e0e7ff 100%);
        }
        
        .node-section {
            border-color: #38b2ac;
            background: linear-gradient(135deg, #e6fffa 0%, #b2f5ea 100%);
        }
        
        .section-title {
            font-size: 1.8em;
            font-weight: 700;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .master-section .section-title {
            color: #5a67d8;
        }
        
        .node-section .section-title {
            color: #2c7a7b;
        }
        
        .component-grid {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .component {
            background: white;
            padding: 15px 20px;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .component:hover {
            transform: translateX(5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.15);
        }
        
        .component.active {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .component-name {
            font-weight: 700;
            font-size: 1.1em;
            color: #2d3748;
            margin-bottom: 5px;
        }
        
        .component-brief {
            font-size: 0.9em;
            color: #718096;
        }
        
        .detail-panel {
            background: white;
            border-radius: 15px;
            padding: 30px;
            margin-top: 30px;
            border: 3px solid #e2e8f0;
            display: none;
        }
        
        .detail-panel.active {
            display: block;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .detail-title {
            font-size: 2em;
            color: #2d3748;
            margin-bottom: 15px;
            font-weight: 700;
        }
        
        .detail-content {
            color: #4a5568;
            line-height: 1.8;
            font-size: 1.05em;
        }
        
        .analogy {
            background: #fef5e7;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #f39c12;
        }
        
        .analogy-title {
            font-weight: 700;
            color: #d68910;
            margin-bottom: 8px;
            font-size: 1.1em;
        }
        
        .key-point {
            background: #e8f5e9;
            padding: 20px;
            border-radius: 10px;
            margin: 15px 0;
            border-left: 4px solid #4caf50;
        }
        
        .key-point-title {
            font-weight: 700;
            color: #2e7d32;
            margin-bottom: 8px;
            font-size: 1.1em;
        }
        
        .flow-diagram {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px dashed #cbd5e0;
        }
        
        .flow-step {
            display: flex;
            align-items: center;
            margin: 10px 0;
            font-size: 1.05em;
        }
        
        .flow-number {
            background: #667eea;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            margin-right: 15px;
            flex-shrink: 0;
        }
        
        @media (max-width: 768px) {
            .cluster-diagram {
                grid-template-columns: 1fr;
            }
        }
        
        .legend {
            display: flex;
            gap: 30px;
            justify-content: center;
            margin: 20px 0;
            padding: 20px;
            background: #f7fafc;
            border-radius: 10px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .legend-icon {
            font-size: 1.5em;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèóÔ∏è Kubernetes Architecture Simplified</h1>
        
        <div class="intro">
            <strong>üéØ The Big Picture:</strong> Kubernetes is like a factory with a control room (Master) and a production floor (Nodes). The control room makes all the decisions about what work needs to be done, and the production floor does the actual work by running your applications in containers.
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <span class="legend-icon">üß†</span>
                <span><strong>Master Server:</strong> The Brain (makes decisions)</span>
            </div>
            <div class="legend-item">
                <span class="legend-icon">üí™</span>
                <span><strong>Worker Nodes:</strong> The Muscle (runs apps)</span>
            </div>
        </div>
        
        <div class="cluster-diagram">
            <div class="master-section">
                <div class="section-title">üß† Master Server (Control Plane)</div>
                <div class="component-grid">
                    <div class="component" data-detail="etcd">
                        <div class="component-name">üìö etcd</div>
                        <div class="component-brief">The database - stores all cluster info</div>
                    </div>
                    <div class="component" data-detail="api-server">
                        <div class="component-name">üéØ API Server</div>
                        <div class="component-brief">The front desk - handles all requests</div>
                    </div>
                    <div class="component" data-detail="scheduler">
                        <div class="component-name">üìã Scheduler</div>
                        <div class="component-brief">The planner - decides where to run apps</div>
                    </div>
                    <div class="component" data-detail="controller-manager">
                        <div class="component-name">üëî Controller Manager</div>
                        <div class="component-brief">The supervisor - makes sure everything runs correctly</div>
                    </div>
                    <div class="component" data-detail="cloud-controller">
                        <div class="component-name">‚òÅÔ∏è Cloud Controller</div>
                        <div class="component-brief">The translator - talks to cloud providers</div>
                    </div>
                </div>
            </div>
            
            <div class="node-section">
                <div class="section-title">üí™ Worker Nodes (Does the Work)</div>
                <div class="component-grid">
                    <div class="component" data-detail="kubelet">
                        <div class="component-name">ü§ñ kubelet</div>
                        <div class="component-brief">The worker - manages containers on this node</div>
                    </div>
                    <div class="component" data-detail="container-runtime">
                        <div class="component-name">üê≥ Container Runtime</div>
                        <div class="component-brief">The engine - actually runs containers (Docker)</div>
                    </div>
                    <div class="component" data-detail="kube-proxy">
                        <div class="component-name">üîå kube-proxy</div>
                        <div class="component-brief">The router - handles networking</div>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="detail-container"></div>
    </div>
    
    <script>
        const details = {
            'etcd': {
                title: "üìö etcd - The Cluster Database",
                content: `
                    <div class="analogy">
                        <div class="analogy-title">üè¢ Real-World Analogy</div>
                        <p>Think of etcd like a company's central filing system where <strong>everything important is stored</strong> - employee records, project status, inventory lists. Everyone needs to check this filing system to know what's happening.</p>
                    </div>
                    
                    <p><strong>What it does:</strong> etcd is a distributed key-value store that holds ALL the configuration and state information for your entire Kubernetes cluster.</p>
                    
                    <div class="key-point">
                        <div class="key-point-title">üîë What's Stored Here</div>
                        <ul style="margin-left: 20px; margin-top: 10px;">
                            <li>What pods should be running</li>
                            <li>Which nodes are in the cluster</li>
                            <li>All configuration settings</li>
                            <li>Secrets and credentials</li>
                            <li>Current state of everything</li>
                        </ul>
                    </div>
                    
                    <p><strong>Why it's important:</strong> If etcd goes down, Kubernetes can't function because it doesn't know what it's supposed to be doing. That's why in production, etcd is usually run on multiple servers for redundancy.</p>
                    
                    <p><strong>Simple Example:</strong> When you tell Kubernetes "run 3 copies of my web app," that instruction gets saved in etcd. Every component reads from etcd to know what work needs to be done.</p>
                `
            },
            'api-server': {
                title: "üéØ API Server - The Front Desk",
                content: `
                    <div class="analogy">
                        <div class="analogy-title">üè¢ Real-World Analogy</div>
                        <p>The API server is like the <strong>receptionist at a company's front desk</strong>. Every request - whether from employees, managers, or visitors - goes through the receptionist. They check who you are, what you need, and direct your request to the right place.</p>
                    </div>
                    
                    <p><strong>What it does:</strong> The API server is the <strong>ONLY</strong> way to interact with your Kubernetes cluster. Everything goes through it - whether you're using kubectl commands, a web dashboard, or automated tools.</p>
                    
                    <div class="flow-diagram">
                        <div style="font-weight: 700; margin-bottom: 15px; color: #2d3748;">How a Request Works:</div>
                        <div class="flow-step">
                            <div class="flow-number">1</div>
                            <div>You run: <code>kubectl create deployment myapp</code></div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">2</div>
                            <div>API server receives the request and validates it</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">3</div>
                            <div>API server saves it to etcd</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">4</div>
                            <div>API server notifies other components about the change</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">5</div>
                            <div>Other components read from API server to do their work</div>
                        </div>
                    </div>
                    
                    <div class="key-point">
                        <div class="key-point-title">üîê Security Gatekeeper</div>
                        <p>The API server also handles authentication and authorization. It checks: "Are you allowed to do this?" before letting any request through.</p>
                    </div>
                    
                    <p><strong>Key Point:</strong> The API server doesn't actually DO the work - it's more like a coordinator that receives requests, stores them, and tells other components what needs to be done.</p>
                `
            },
            'scheduler': {
                title: "üìã Scheduler - The Smart Planner",
                content: `
                    <div class="analogy">
                        <div class="analogy-title">üè¢ Real-World Analogy</div>
                        <p>The scheduler is like a <strong>project manager assigning tasks to team members</strong>. They look at who's available, who has the right skills, who's not too busy, and then assign the work accordingly.</p>
                    </div>
                    
                    <p><strong>What it does:</strong> When a new pod needs to run, the scheduler's job is to figure out <strong>which node (server) should run it</strong>.</p>
                    
                    <div class="flow-diagram">
                        <div style="font-weight: 700; margin-bottom: 15px; color: #2d3748;">How Scheduling Works:</div>
                        <div class="flow-step">
                            <div class="flow-number">1</div>
                            <div>Scheduler sees: "New pod needs to run"</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">2</div>
                            <div>Checks what the pod needs (memory, CPU, storage)</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">3</div>
                            <div>Looks at all nodes: which ones have enough resources?</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">4</div>
                            <div>Picks the best node based on various factors</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">5</div>
                            <div>Tells the API server: "Put this pod on Node #3"</div>
                        </div>
                    </div>
                    
                    <div class="key-point">
                        <div class="key-point-title">üßÆ What It Considers</div>
                        <ul style="margin-left: 20px; margin-top: 10px;">
                            <li><strong>Resources:</strong> Does the node have enough CPU and memory?</li>
                            <li><strong>Constraints:</strong> Does the pod need to run on specific hardware?</li>
                            <li><strong>Affinity:</strong> Should it run near or far from other pods?</li>
                            <li><strong>Balance:</strong> Spread work evenly across nodes</li>
                        </ul>
                    </div>
                    
                    <p><strong>Important:</strong> The scheduler only decides WHERE to run pods. It doesn't actually start them - that's kubelet's job (on the worker node).</p>
                `
            },
            'controller-manager': {
                title: "üëî Controller Manager - The Supervisor",
                content: `
                    <div class="analogy">
                        <div class="analogy-title">üè¢ Real-World Analogy</div>
                        <p>The controller manager is like a <strong>building supervisor with multiple responsibilities</strong>. They constantly walk around checking: "Are there enough security guards? Is maintenance being done? Are all the lights working?" When something's wrong, they fix it.</p>
                    </div>
                    
                    <p><strong>What it does:</strong> The controller manager runs multiple "controllers" - each is like a background process that watches for differences between what SHOULD be happening and what IS happening, then fixes any problems.</p>
                    
                    <div class="key-point">
                        <div class="key-point-title">üîÑ Different Controllers Inside</div>
                        <ul style="margin-left: 20px; margin-top: 10px;">
                            <li><strong>Replication Controller:</strong> "Are there 5 copies running? Only 3? Better start 2 more!"</li>
                            <li><strong>Node Controller:</strong> "Is node #2 still alive? No? Mark it as down!"</li>
                            <li><strong>Endpoints Controller:</strong> "Update the list of healthy pods for this service"</li>
                            <li><strong>Service Account Controller:</strong> "Create accounts and credentials for new namespaces"</li>
                        </ul>
                    </div>
                    
                    <div class="flow-diagram">
                        <div style="font-weight: 700; margin-bottom: 15px; color: #2d3748;">How It Works (Continuous Loop):</div>
                        <div class="flow-step">
                            <div class="flow-number">1</div>
                            <div>Watch etcd for the desired state (via API server)</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">2</div>
                            <div>Check the actual current state</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">3</div>
                            <div>If they don't match, take action to fix it</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">4</div>
                            <div>Repeat forever</div>
                        </div>
                    </div>
                    
                    <p><strong>Example:</strong> You create a Deployment for 3 replicas. The Replication Controller (inside the Controller Manager) constantly checks: "Are 3 pods running? One crashed? I'll tell the scheduler to start a new one!"</p>
                `
            },
            'cloud-controller': {
                title: "‚òÅÔ∏è Cloud Controller Manager - The Translator",
                content: `
                    <div class="analogy">
                        <div class="analogy-title">üè¢ Real-World Analogy</div>
                        <p>The cloud controller is like a <strong>translator at a United Nations meeting</strong>. Different cloud providers (AWS, Google Cloud, Azure) all speak different "languages" and have different ways of doing things. The cloud controller translates Kubernetes' requests into what each cloud provider understands.</p>
                    </div>
                    
                    <p><strong>What it does:</strong> Kubernetes needs to interact with cloud-specific resources (like load balancers, storage volumes, and virtual machines), but each cloud provider has its own API and way of doing things. The cloud controller bridges this gap.</p>
                    
                    <div class="key-point">
                        <div class="key-point-title">‚òÅÔ∏è What It Manages</div>
                        <ul style="margin-left: 20px; margin-top: 10px;">
                            <li><strong>Nodes:</strong> Talks to cloud API to get info about virtual machines</li>
                            <li><strong>Load Balancers:</strong> Creates/manages cloud load balancers for Services</li>
                            <li><strong>Routes:</strong> Sets up networking routes in the cloud</li>
                            <li><strong>Storage:</strong> Provisions cloud storage volumes</li>
                        </ul>
                    </div>
                    
                    <p><strong>Example:</strong> You create a Kubernetes Service of type "LoadBalancer". The cloud controller sees this and tells AWS to create an Elastic Load Balancer (or tells Google Cloud to create a Google Cloud Load Balancer - whatever cloud you're using).</p>
                    
                    <div class="analogy">
                        <div class="analogy-title">üí° Why This Matters</div>
                        <p>Without the cloud controller, Kubernetes would need built-in knowledge of every cloud provider. This design keeps Kubernetes generic and cloud-agnostic - it just needs the right cloud controller plugin for your provider.</p>
                    </div>
                `
            },
            'kubelet': {
                title: "ü§ñ kubelet - The Worker on Each Node",
                content: `
                    <div class="analogy">
                        <div class="analogy-title">üè¢ Real-World Analogy</div>
                        <p>Think of kubelet as the <strong>site manager at each construction site</strong>. The main office (Master) sends instructions about what needs to be built, and the site manager (kubelet) makes sure it actually gets done and reports back on progress.</p>
                    </div>
                    
                    <p><strong>What it does:</strong> Kubelet is an agent that runs on EVERY worker node. It's the primary point of contact between the Master and each Node. It makes sure containers are running as they should be.</p>
                    
                    <div class="flow-diagram">
                        <div style="font-weight: 700; margin-bottom: 15px; color: #2d3748;">Kubelet's Daily Job:</div>
                        <div class="flow-step">
                            <div class="flow-number">1</div>
                            <div>Regularly checks with API server: "Any work for me?"</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">2</div>
                            <div>API server says: "Run these pods on your node"</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">3</div>
                            <div>Kubelet tells Container Runtime: "Start these containers"</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">4</div>
                            <div>Monitors containers: Are they healthy? Still running?</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">5</div>
                            <div>Reports status back to API server</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">6</div>
                            <div>Repeat forever</div>
                        </div>
                    </div>
                    
                    <div class="key-point">
                        <div class="key-point-title">üîß What It Manages</div>
                        <ul style="margin-left: 20px; margin-top: 10px;">
                            <li>Starting and stopping containers</li>
                            <li>Monitoring container health</li>
                            <li>Mounting storage volumes</li>
                            <li>Reporting node and pod status</li>
                            <li>Running health checks on containers</li>
                        </ul>
                    </div>
                    
                    <p><strong>Key Point:</strong> Kubelet is what actually executes the Master's decisions. Without kubelet, your nodes would be deaf to the Master's commands.</p>
                `
            },
            'container-runtime': {
                title: "üê≥ Container Runtime - The Engine",
                content: `
                    <div class="analogy">
                        <div class="analogy-title">üè¢ Real-World Analogy</div>
                        <p>The container runtime is like the <strong>actual engine that runs machines in a factory</strong>. The foreman (kubelet) tells you what to make, but the engine is what actually powers the machinery to do the work.</p>
                    </div>
                    
                    <p><strong>What it is:</strong> The software that actually runs containers. Docker is the most famous one, but there are others like containerd, CRI-O, and rkt.</p>
                    
                    <div class="key-point">
                        <div class="key-point-title">üõ†Ô∏è What It Does</div>
                        <ul style="margin-left: 20px; margin-top: 10px;">
                            <li><strong>Pulling images:</strong> Downloads container images from registries (like Docker Hub)</li>
                            <li><strong>Starting containers:</strong> Actually launches the containerized applications</li>
                            <li><strong>Stopping containers:</strong> Shuts them down when told to</li>
                            <li><strong>Managing container lifecycle:</strong> Handles all low-level container operations</li>
                        </ul>
                    </div>
                    
                    <div class="flow-diagram">
                        <div style="font-weight: 700; margin-bottom: 15px; color: #2d3748;">How a Container Starts:</div>
                        <div class="flow-step">
                            <div class="flow-number">1</div>
                            <div>Kubelet says: "Run container from image 'nginx:latest'"</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">2</div>
                            <div>Container Runtime checks: Do I have this image? If not, download it.</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">3</div>
                            <div>Container Runtime creates an isolated environment (namespaces, cgroups)</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">4</div>
                            <div>Container Runtime starts the container process</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">5</div>
                            <div>Container is now running!</div>
                        </div>
                    </div>
                    
                    <p><strong>Important:</strong> While Kubernetes orchestrates everything at a high level, the container runtime is doing the actual low-level work of running your applications.</p>
                `
            },
            'kube-proxy': {
                title: "üîå kube-proxy - The Network Manager",
                content: `
                    <div class="analogy">
                        <div class="analogy-title">üè¢ Real-World Analogy</div>
                        <p>kube-proxy is like the <strong>mail room and switchboard operator</strong> in a large office building. When someone sends a message to "Department Sales," the mail room knows which specific rooms (pods) are in the Sales department and delivers the message to the right place.</p>
                    </div>
                    
                    <p><strong>What it does:</strong> Manages networking rules on each node so that traffic can reach the right pods. It's what makes Kubernetes Services work.</p>
                    
                    <div class="key-point">
                        <div class="key-point-title">üåê The Networking Problem</div>
                        <p>Remember: Pods have IP addresses, but they come and go. Services give you a stable IP/DNS name, but HOW does traffic actually get from the Service to the right Pods? That's kube-proxy's job!</p>
                    </div>
                    
                    <div class="flow-diagram">
                        <div style="font-weight: 700; margin-bottom: 15px; color: #2d3748;">How Traffic Flows:</div>
                        <div class="flow-step">
                            <div class="flow-number">1</div>
                            <div>Request comes to Service IP (e.g., 10.0.0.5)</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">2</div>
                            <div>kube-proxy has rules: "Traffic to 10.0.0.5 should go to these pods"</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">3</div>
                            <div>kube-proxy forwards traffic to one of the healthy pods</div>
                        </div>
                        <div class="flow-step">
                            <div class="flow-number">4</div>
                            <div>Can load balance between multiple pods</div>
                        </div>
                    </div>
                    
                    <p><strong>Technical Detail:</strong> kube-proxy typically uses iptables or IPVS rules (Linux networking features) to handle this traffic routing very efficiently.</p>
                    
                    <div class="key-point">
                        <div class="key-point-title">üéØ Why Each Node Needs It</div>
                        <p>Every node runs kube-proxy because traffic can come into ANY node, and kube-proxy ensures that no matter which node receives the traffic, it can route it to the correct pod (even if that pod is on a different node).</p>
                    </div>
                `
            }
        };
        
        const components = document.querySelectorAll('.component');
        const detailContainer = document.getElementById('detail-container');
        
        components.forEach(component => {
            component.addEventListener('click', () => {
                const detailKey = component.dataset.detail;
                const detail = details[detailKey];
                
                components.forEach(c => c.classList.remove('active'));
                component.classList.add('active');
                
                detailContainer.innerHTML = `
                    <div class="detail-panel active">
                        <div class="detail-title">${detail.title}</div>
                        <div class="detail-content">${detail.content}</div>
                    </div>
                `;
                
                detailContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            });
        });
        
        // Show API server by default
        document.querySelector('[data-detail="api-server"]').click();
    </script>
</body>
</html>